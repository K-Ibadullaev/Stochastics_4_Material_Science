#reading and writing files
data()# all preloaded data sets
rivs = read.tables(data("rivers"))
rivs = read.table(data("rivers"))
library(help="datasets")
library(help="datasets")
library(tseries)
rivs = read.table(data("ice.rivers"))
rivs = (data("ice.rivers"))
rivs = data("ice.rivers")
rivs = data("ice.river")
head(rivs)
rivs
library(tseries)
data("ice.river")
head(ice.river)
data("ice.river")
head(ice.river)
rivs = data("ice.river")
rivs
head(ice.river)
(head(rivs))
rivs = data("ice.river")
library(help="datasets")
rivs = as.data.frame(data("ice.river"))
rivs
rivs = as.data.frame(ice.river)
rivs
head(rivs)
tapply(rivs$temp,INDEX = rivs$flow.vat FUN = mean)
tapply(rivs$temp,INDEX = rivs$flow.vat, FUN = mean)
tapply(rivs$flow.vat,INDEX =rivs$temp , FUN = mean)
tapply(rivs$flow.vat[1:10],INDEX =rivs$temp[1:10] , FUN = mean)
#lapply
baz <- list(aa=c(3.4,1),bb=matrix(1:4,2,2),cc=matrix(c(T,T,F,T,F,F),3,2),
dd="string here",ee=matrix(c("red","green","blue","yellow")))
lapply(baz, FUN = is.matrix)
lapply(baz, FUN = is.matrix) #return list form
sapply(baz,FUN=is.matrix) #array form
#repeat
fib.a =1
fib.b =1
repeat{
tmp=fib.a + fib.b
fib.a =fib.b
fib.b =tmp
cat(fib.b,", ",sep="")
if(fib.b>150){
cat("BREAK NOW...\n")
break
}
}
myfib = function(){
fib.a = 1
fib.b= 1
cat(fib.a,", ",fib.b,", ",sep="")
repeat{
tmp = fib.a + fib.b
fib.a = fib.b
fib.b = temp
cat(fib.b , ", ",sep = "" )
if (fib.b>150){
cat("break now")
break
}
}
}
source('C:/Users/Anaconda/Rscripts/r_common/write_func.R')
myfib = function(){
fib.a = 1
fib.b= 1
cat(fib.a,", ",fib.b,", ",sep="")
repeat{
tmp = fib.a + fib.b
fib.a = fib.b
fib.b = temp
cat(fib.b , ", ",sep = "" )
if (fib.b>150){
cat("break now")
break
}
}
}
myfib = function(){
fib.a = 1
fib.b= 1
cat(fib.a,", ",fib.b,", ",sep="")
repeat{
tmp = fib.a + fib.b
fib.a = fib.b
fib.b = temp
cat(fib.b , ", ",sep = "" )
if (fib.b>150){
cat("break now")
break
}
}
}
myfib()
myfib()
myfib = function(){
fib.a = 1
fib.b= 1
cat(fib.a,", ",fib.b,", ",sep="")
repeat{
tmp = fib.a + fib.b
fib.a = fib.b
fib.b = tmp
cat(fib.b , ", ",sep = "" )
if (fib.b>150){
cat("break now")
break
}
}
}
myfib()
if (fib.b>tresh){
cat("break now")
break
}
myfib = function(thresh){
fib.a = 1
fib.b= 1
cat(fib.a,", ",fib.b,", ",sep="")
repeat{
tmp = fib.a + fib.b
fib.a = fib.b
fib.b = tmp
cat(fib.b , ", ",sep = "" )
if (fib.b>tresh){
cat("break now")
break
}
}
}
myfib(thresh = 20)
if (fib.b>thresh){
cat("break now")
break
}
myfib = function(thresh){
fib.a = 1
fib.b= 1
cat(fib.a,", ",fib.b,", ",sep="")
repeat{
tmp = fib.a + fib.b
fib.a = fib.b
fib.b = tmp
cat(fib.b , ", ",sep = "" )
if (fib.b>thresh){
cat("break now")
break
}
}
}
myfib(thresh = 20)
return(fibseq)
vecfib = function(thresh){
fib.seq =c(1,1)
counter =2
repeat{
fib.seq= c(fib.seq, fib.seq[counter-1]+fib.seq[counter])
counter = counter +1
if (fib.seq[counter]>thresh){
break
}
}
return(fibseq)
}
vecfib(300)
return(fib.seq)
return(fib.seq)
vecfib(300)
vecfib = function(thresh){
fibseq =c(1,1)
counter =2
repeat{
fibseq= c(fibseq, fibseq[counter-1]+fibseq[counter])
counter = counter +1
if (fibseq[counter]>thresh){
break
}
}
return(fibseq)
}
vecfib(24)
a =myfib(12)
a
b =vecfib(24)
b
# Load contributed R package 'spatstat', and, if necessary, install it beforehand:
if(!require(spatstat)) {install.packages("spatstat"); require(spatstat)}
# That means, if a contributed R package has b\een already installed,
# then it suffices to load it by running 'require(name_of_package)' or 'library(name_of_package)'.
library(spatstat)
bronzefilter # This is a real marked point pattern from the package 'spatstat'.
plot(bronzefilter) # The values of real-valued marks are indicated by different circle sizes.
plot(unmark(bronzefilter),main="centers",pch=20) # Shows only the centers of the mark point pattern 'bronzefilter'.
# Load contributed R package 'EBImage', and, if necessary, install it beforehand:
if(!require(EBImage)) {
install.packages("BiocManager", version = "3.11")
BiocManager::install("EBImage", version = "3.11")
require(EBImage)
}
install.packages("BiocManager", version = "3.11")
library(EBImage)
# Load contributed R package 'EBImage', and, if necessary, install it beforehand:
if(!require(EBImage)) {
install.packages("BiocManager")
BiocManager::install("EBImage")
require(EBImage)
}
install.packages("BiocManager")
library(EBImage)
install.packages(EBImage)
install.packages("EBImage")
install.package("EBImage")
install.packageы("EBImage")
install.packages("EBImage")
# Load contributed R package 'EBImage', and, if necessary, install it beforehand:
if(!require(EBImage)) {
install.packages("BiocManager")
BiocManager::install("EBImage")
require(EBImage)
}
# Load contributed R package 'EBImage', and, if necessary, install it beforehand:
if(!require(EBImage)) {
install.packages("BiocManager")
BiocManager::install("EBImage")
require(EBImage)
}
# Load contributed R package 'EBImage', and, if necessary, install it beforehand:
if(!require(EBImage)) {
install.packages("BiocManager")
BiocManager::install("EBImage")
require(EBImage)
}
source('C:/Users/Anaconda/Rscripts/StoMe/3.R')
setwd("C:/Users/Anaconda/Rscripts/StoMe/project")
source(fcts)
source("fcts.r")
library(EBImage)
library(spatstat)
library(bitops)
img1 = readImage("image1_ID.png")
img1 = readImage("image1_01.png")
setwd("C:/Users/Anaconda/Rscripts/StoMe/project")
x0 <- readImage(system.file('images', 'nuclei.tif', package='EBImage'), all=FALSE)
x0 # essentially a matrix with grey values between 0 and 1
display(x0, method="raster") # 'display' is a command of package 'EBImage' for displaying images
img1 = readImage('image1_01.png')
setwd("C:/Users/Anaconda/Rscripts/StoMe/project")
img1 = readImage('image1_03.png')
img1
display(img1,method="raster"  )
img2 = readImage('image2_03.png')
display(img1,method="raster"  )
#Load images
img1 = readImage('image1_03.png')
display(img1,method="raster"  )
img2 = readImage('image2_03.png')
display(img1,method="raster"  )
#Load images
img1 = readImage('image1_03.png')
display(img1,method="raster"  )
img2 = readImage('image2_03.png')
display(img1,method="raster"  )
#Load images
img1 = readImage('image1_03.png')
display(img1,method="raster"  )
img2 = readImage('image2_03.png')
display(img2,method="raster"  )
img1.ALX = estALXFct(BW=img1, m=20, spacing=0.1, ms=FALSE)
img1.ALX
img1.ALX = estALXFct(BW=img1, spacing=0.025, ms=FALSE)
img1.ALX
img1.ALX = estALXFct(BW=img1,m=20 spacing=0.025, ms=FALSE)
img1.ALX
img1.ALX = estALXFct(BW=img1,m=20, spacing=0.025, ms=FALSE)
img1.ALX
# Load contributed R package 'bitops', and, if necessary, install it beforehand:
if(!require(bitops)) {install.packages("bitops"); require(bitops)}
# Load contributed R package 'EBImage':
require(EBImage)
y2 <- readImage('example2.png')
display(y2, method="raster")
setwd("C:/Users/Anaconda/Rscripts/StoMe")
# Load contributed R package 'bitops', and, if necessary, install it beforehand:
if(!require(bitops)) {install.packages("bitops"); require(bitops)}
# Load contributed R package 'EBImage':
require(EBImage)
y2 <- readImage('example2.png')
display(y2, method="raster")
y2@.Data # shows the matrix of zeros and ones
# Let's convince ourselves that zeros represent black pixels and ones represent white pixels:
y2temp <- y2
y2temp@.Data <- 0 * y2temp@.Data # set all entries to 0
display(y2temp, method="raster")
rm(y2temp) # remove 'y2temp' from workspace
# The R script file 'estALX.r' contains (only) a self-written function 'estALX' which estimates
# area fraction A_A, specific boundary length L_A and specific Euler number chi_A of a realization of a random set
# given as a black-white pixel image. It uses the relationship of Thm. 3.28 as well as ideas to measure length and
# Euler number of a pixelated set not demonstrated in the lecture (see book of Ohser/MГјcklich 2000).
# The following command runs everything in 'estALX.r' and thus loads the function 'estALX' in the workspace.
source('estALX.r')
# Now 'estALX' can be applied:
estALX(y2@.Data,spacing=0.1) # The argument 'spacing' is the length of a pixel side, for instance in millimeters.
setwd("C:/Users/Anaconda/Rscripts/StoMe/project")
source("fcts.r")
library(EBImage)
library(spatstat)
library(bitops)
#Load images
img1 = readImage('image1_03.png')
display(img1,method="raster"  )
img2 = readImage('image2_03.png')
display(img2,method="raster"  )
#Estimate Minkowsky functions
img1.ALX = estALX(BW=img1, spacing=0.025, ms=FALSE)
#Estimate Minkowsky functions
img1.ALX = estALX(img1, spacing=0.025)
img1.ALX
img2.ALX = estALX(img2, spacing=0.025)
img2.ALX
img2.ALX = estALXFct(BW=img2,m=20, spacing=0.025, ms=FALSE)
#Estimate Minkowsky functions
img1.ALX = estALXFct(BW=img1,m=20, spacing=0.025, ms=FALSE)
img1.ALX
img2.ALX = estALXFct(BW=img2,m=20, spacing=0.025, ms=FALSE)
img2.ALX
#Plot functions
plotALXFct(BW=img2, ALX=img2.ALX, ALX2=img2.ALX.ms, show.type=1)
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=1)
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
#Estimate Minkowsky functions
img1.ALX = estALXFct(BW=img1,m=10, spacing=0.025, ms=FALSE)
img1.ALX
img2.ALX = estALXFct(BW=img2,m=10, spacing=0.025, ms=FALSE)
img2.ALX
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
# Load contributed R package 'bitops':
require(bitops)
# Load contributed R package 'EBImage':
require(EBImage)
# Read an example image:
y2 <- readImage('example2.png')
display(y2, method="raster")
# In the following the set of white pixels of 'y2' plays the role of the first set A.
A <- y2
# 'makeBrush' may be used to generate typical structuring elements B like
# a square
makeBrush(size=3, shape='box')
makeBrush(size=5, shape='box')
# or a disc.
makeBrush(size=5, shape='disc')
display(makeBrush(size=15, shape='disc'), method="raster", interpolate=FALSE)
display(makeBrush(size=51, shape='disc'), method="raster", interpolate=FALSE)
B1 <- makeBrush(size=3, shape='disc') # disc of radius 1 pixel
B2 <- makeBrush(size=5, shape='disc') # disc of radius 2 pixels
# dilation / Minkowski sum
display(dilate(A, B1), method="raster", interpolate=FALSE)
display(dilate(A, B2), method="raster", interpolate=FALSE)
# erosion / Minkowski difference
display(erode(A, B1), method="raster", interpolate=FALSE)
display(erode(A, B2), method="raster", interpolate=FALSE)
# morphological opening (white holes in the black phase are reduced or filled)
display(opening(A, B1), method="raster", interpolate=FALSE)
display(opening(A, B2), method="raster", interpolate=FALSE)
# morphological closing (black holes in the white phase are reduced or filled)
display(closing(A, B1), method="raster", interpolate=FALSE)
display(closing(A, B2), method="raster", interpolate=FALSE)
display(A, method="raster")
# denoising with B1
display(opening(closing(A, B1), B1), method="raster", interpolate=FALSE)
# denoising with B2
display(opening(closing(A, B2), B2), method="raster", interpolate=FALSE)
# Load the function 'estALX' in the workspace which estimates A_A, L_A and chi_A:
source('estALX.r')
# Apply 'estALX' to 'y2':
estALX(y2@.Data, spacing=0.1)
# The following function 'estALXFct' performs the estimation of the Minkowski functions A_A(r), L_A(r) and chi_A(r)
# for the black-white image 'BW' for arguments r from (0,1,...,m)*spacing.
# 'spacing' is the real pixel length.
# By 'ms' minus-sampling correction can be employed ('ms=TRUE') or supressed ('ms=FALSE').
estALXFct <- function(BW, m=0, spacing=1, ms=FALSE, shape='disc') {
rr <- 0:m
d <- dim(BW)
cbind(r=rr*spacing, t(sapply(rr, function(r) estALX(dilate(BW, makeBrush(size=2*r+1, shape=shape))[(1+ms*r):(d[1]-ms*r),(1+ms*r):(d[2]-ms*r)]@.Data, spacing=spacing))))
}
# Apply 'estALXFct' to 'y2' (without minus sampling correction):
y2.ALX <- estALXFct(BW=y2, m=20, spacing=0.1, ms=FALSE)
y2.ALX
# The R script file 'plotit.r' contains a self-written function 'plotALXFct' to show the results.
# Load 'plotALXFct' in the workspace:
source('plotit.r')
# Show the results alltogether ('show.type=0'):
plotALXFct(BW=y2, ALX=y2.ALX, show.type=0)
# Show only estimate of A_A(r) ('show.type=1'):
plotALXFct(BW=y2, ALX=y2.ALX, show.type=1)
# Show only estimate of L_A(r) ('show.type=2'):
plotALXFct(BW=y2, ALX=y2.ALX, show.type=2)
# Show only estimate of chi_A(r) ('show.type=3'):
plotALXFct(BW=y2, ALX=y2.ALX, show.type=3)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
e
#legend
legend("bottomleft", legend = c("img1","img2"),
col=c("black","blue","black","darkmagenta","darkgreen","red","red"))
#legend
legend("bottomleft", legend = c("img1","img2"),
col=c("red","blue"))
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
#legend
legend("bottomleft", legend = c("img1","img2"),
col=c("red","blue"))
#legend
legend("bottomleft", legend = c("img1.ALX","img2.ALX"),col=c("red","blue"))
source("fcts.r")
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
source("fcts.r")
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
source("fcts.r")
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
source("fcts.r")
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
source("fcts.r")
library(EBImage)
library(spatstat)
library(bitops)
#Load images
img1 = readImage('image1_03.png')
display(img1,method="raster"  )
img2 = readImage('image2_03.png')
display(img2,method="raster"  )
#Estimate Minkowsky functions
img1.ALX = estALXFct(BW=img1,m=10, spacing=0.025, ms=FALSE)
img1.ALX
img2.ALX = estALXFct(BW=img2,m=10, spacing=0.025, ms=FALSE)
img2.ALX
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
source("fcts.r")
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
source("fcts.r")
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
source("fcts.r")
library(EBImage)
library(spatstat)
library(bitops)
#Load images
img1 = readImage('image1_03.png')
display(img1,method="raster"  )
img2 = readImage('image2_03.png')
display(img2,method="raster"  )
#Estimate Minkowsky functions
img1.ALX = estALXFct(BW=img1,m=10, spacing=0.025, ms=FALSE)
img1.ALX
img2.ALX = estALXFct(BW=img2,m=10, spacing=0.025, ms=FALSE)
img2.ALX
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=1)
#Plot functions
plotALXFct(BW=img1, ALX=img1.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img2.ALX, show.type=0)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=1)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=2)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=1)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=2)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=3)
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=1,add=T)
plot(add=T)
for (i = 1:3){
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=i)
}
for (i in 1:3){
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=i)
}
for (i in 1:3){
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=i)
i= i+1
}
for (i in 1:3){
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=i)
i= i+1
}
for (i in 1:3){
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=i)
i= i+1
}
for (i in 1:3){
plotALXFct(BW=img2, ALX=img1.ALX, ALX2 =img2.ALX ,show.type=i)
}
